# Demand Paging

* 프로그래머 입장에서는 모든 메모리를 즉시 사용할 수 있는 것처럼 보이지만, 실제로는 메모리 로딩도 동적으로 이루어진다.
* 메모리 사용 효율성을 위한 설계
* Page Fault에 따른 오버헤드가 있지만 메모리 낭비보다 크지는 않음

## Pure Demand Paging

* 프로세스는 Page Fault가 날 때까지 스왑되지 않는다.

## Performance of Demand Paging

* 메모리 접근에 2ns(500MHz)의 시간이 걸리고 Page Fault 발생할 경우 80us의 시간이 걸린다.
* 만약 Page Fault가 확률 P만큼 발생한다고 하면 메모리 접근 시간은 (1-p)*(2) + p*(80000)=2+79998*p
* P가 0.001일 경우 메모리 접근 시간은 40배 넘게 느려짐
* 10% 이내로 느려지게 하려면 P를 0.0000025까지 낮춰야만 하는데 이는 약 40만번에 1번 Page Fault가 나는 꼴임
* 실제 Page 크기가 4kb라고 하면 1000번의 메모리 접근 동안에는 Page Fault가 없음

# Copy-on-Write

* 프로세스가 자신과 같은 프로세스를 만들 때 페이지 할당을 서로 같은 페이지 번호를 할당해 줌
* 읽기의 경우에는 프로세스가 같은 것을 공유해도 상관없기 때문임
* 만약 어떤 프로세스가 쓰기를 하려고 할 경우에만 새로운 페이지를 할당해 줌

# Page Replacement

* 남은 프레임이 없을 경우, 어떤 프레임을 스왑 메모리에 옮겨서 프레임을 비워야 한다.
* 만약 어떤 프레임이 새로 변경된 데이터가 없는 경우(dirty bit false)에는 스왑 메모리에 다시 쓸 필요가 없다.
* 코드 데이터를 저장하는 캐시에는 dirty bit 자체가 없음
1. victim 프레임을 스왑 메모리로 옮긴다.
2. 페이지 테이블의 해당 프레임에 invaild bit를 설정한다.
3. 비운 프레임에 데이터를 적재한다.
4. 페이지 테이블의 해당 프레임에 vaild bit를 설정한다.

## Page Peplacement Algorithm

### FIFO

* 가장 먼저 들어온 프레임을 스왑시킨다.
* 구현이 간단하지만 비효율적이다.
* 비효율적이지만 멀티프로세서 환경에서는 가장 현실적인 방법이다.

#### Belady's anomaly

* 직관적으로 프레임 수가 많아지면 Page Fault가 줄어들 것으로 예상되지만 실험적으로 보면 관계가 역전되는 구간이 나타남

### Optimal

* 미래에 사용될 프레임을 알고 있다면 가장 오랫동안 쓰이지 않을 프레임을 빼는 것이 가장 좋음.
* 비현실적인 가정이지만 성능 평가의 지표로서 의미를 갖는다.

### LRU

* 과거로부터 현재를 유추: 최근에 불렸던 프레임은 미래에도 불릴 확률이 높다.
* 현재 프레임들 중에서 가장 오랫동안 사용하지 않은 프레임을 빼는 알고리즘.
* 현실적인 가정 하에서 가장 이상적이지만 오버헤드가 존재하고 하드웨어로 구현하기가 어렵다.
