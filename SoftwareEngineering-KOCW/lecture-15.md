# 테스트와 유지보수

## 하향식 통합

* 시스템 구조도의 위에 있는 모듈부터 아래층의 모듈로 내려오면서 통합
* 점증적 통합이므로 하드웨어의 사용이 분산되고 오류의 원인을 찾아내기 쉬움
* 상위층의 중요한 모듈을 먼저 시험(시스템의 골격을 조기에 테스트함)
* 스텁의 사용으로 시스템의 모양을 사용자에게 조기에 보여줄 수 있음
* 프로그래머가 시스템의 작동에 대한 확신을 유지시킬 수 있음

## 상향식 통합

* 최하위 모듈을 먼저 시험
* 드라이버가 필요
* 오류 발견이 쉽고 하드웨어의 사용을 분산
* 하위층의 모듈을 상위층보다 더 많이 시험
* 테스트의 초기의 뼈대가 갖추어지지 않음

## 연쇄식 통합

* 최선의 통합 방법
* 어느 정도의 기본 기능을 수행하는 모듈로부터 통합
* 시스템의 중요한 기능을 담당하는 모듈부터 통합
* 초기에 시스템을 골격을 보여주고 사용자의 의견을 받아 수정 가능

## 인수 테스트

* 목적
    * 시스템이 사용할 수 있도록 모든 준비가 되어 있는지를 보이는 것
    * 사용할 모든 준비가 되었다는 것을 확인시켜 주는 작업
* 테스트 방법은 사용자가 선택
* 인수 테스트 방법의 대부분은 통합 테스트와 같음, 다른 점은 사용자 환경에서 한다는 것
* 베타 테스트
    * 고객의 사용 환경에서 시험
    * 개발자 없이 사용 환경에 소프트웨어를 설치하여 시험

## 테스트 자동화 도구

### 코드 분석 도구

* 정적 분석 도구
    * 코드 분석 도구 : 원시 코드의 문버적 적합성을 자동으로 평가하여 잘못된 문장을 표기
    * 구조 검사 도구 : 원시 코드의 그래프를 통칭하여 논리 흐름을 보여주고 구조적인 결함이 있는지 체크
    * 데이터 분석 도구 : 원시 코드에 정의된 데이터 구조, 데이터 선언, 컴포넌트 인터페이스를 검사, 잘못된 링크나 데이터 정의의 충돌, 잘못된 데이터의 사용 등을 발견
    * 순서 검사 도구 : 이벤트의 순서 체크, 잘못된 순서로 코딩되어 있다면 이벤트를 지적

* 동적 분서 도구
    * 프로그램의 수정되는 동안 이벤트의 상태를 검색하기 위하여 특정한 변수나 조건의 스냅샷을 생성

## 테스트 케이스 생성 도구

* 자료 흐름도
    * 원시 프로그램을 입력받아 파싱한 후 자료 흐름도를 작성
    * define-use 관계
    * 찾으려는 변수에 영향을 주는 요소들을 모아 테스트 경로를 구동시키는 입력값들을 찾아낸다.

* 기능 테스트
    * 주어진 기능을 구동시키는 모든 가능한 상태를 파악하여 이에 대한 입력을 작성

* 입력 도메인 분석
    * 원시 코드의 내부를 참조하지 않고
    * 입력 변수가 가질 수 있는 값의 도메인 분석

* 랜덤 테스트
    * 입력 값을 무작위로 추출
    * 시스템의 신뢰성 분석에 사용

## 테스트 실행 도구

* 캡처 및 리플레이
    * 테스트 계획에 표시된 테스트 데이터를 자동으로 입력하고 실행 과정에 발생하는 화면이나 인쇄되는 결과를 갭처
    * 예상되는 결과와 비교
    * 예상되는 결과와 차이를 보일 경우 테스트 프로그래머에게 보고
    * 오류를 발견하고 수정한 후 고치는 작업이 바르게 되었는지 확인하는데 유용

* 자동적으로 스텁과 드라이벌르 생성하는 도구

* 자동 테스트 환경
    * 테스트 수행 도구들이 테스트 환경으로 통합되어 제공

# 유지보수

## 유지보수

* 소프트웨어가 인수 설치된 후 일어나는 모든 작업
* 소프트웨어가 유용하게 활용되는 기간
* 소프트웨어 유형에 따라 비용이 많이 들 수 있다.

## 유지보수가 어려운 경우

* 소프트웨어 특성
    1. 비가시성(invisibility)
    2. 복잡성(complexity)
    3. 변경용이성(changeability)

* old code

* 관리의 부재

## 유지보수의 종류

* 정정(corrective maintenance) : 발견된 오류의 원인을 찾아 문제해결, A/S의 개념
* 개작(adaptive maintenance) : 새로운 자료나 운영체제, 하드웨어 환경으로 이식
* 기능 개선(perfective maintenance) : 새로운 기능의 추가
* 예방(preventive maintenance) : 유지보수성, 신뢰성 향상, 구조 변경

## 유지보수 작업 과정

1. 소프트웨어의 이해
    * 문서, 코드 리딩
    * 프로그램의 구조 파악
    * domain knowledge 습득
    * 변수와의 관계, 서브루틴 사이의 관계 파악
    * 코드 안에 숨겨진 의미(semantic) 파악
    * 분석 도구(call graph, cross-reference table 등), 디버깅 도구 사용

2. 변경 요구분석
    * 변경이 불가피한 이유와 요구를 이해
    * 기능 향상의 경우는 새로운 기능의 분석

3. 변경 및 효과 예측
    * code change
    * change effect 분석

4. 리그레션 테스트
    * 변경 부분과 그에 의하여 영향이 있는 부분만 테스트
    * 다양한 기술이 필요

## 유지보수 비용

* 개발 30%
* 유지보수 70%
    * 50% 기능 개선
    * 25% 개작
    * 21% 정정
    * 4% 예방

* 유지보수의 생산성은 개발의 1/40

## 유지보수의 문제점

* 소프트웨어에 대한 변경이 수시로 일어나며 이를 문서에 반영하지 않는 경우 이를 추적하는 것은 거의 불가능하다.
* 다른 사람이 작성한 프로그램을 이해하는 일은 쉽지 않다. 문서화되어 있지 않거나 주석도 달지 않았다면 문제는 매우 심각하다.
* 소프트웨어가 변경을 가정하여 설계되는 경우가 드물다.
* 관리적인 측면에서 유지보수를 담당하는 프로그래머에게 동기부여를 하지 못 한다.
* 유지보수를 위한 적극적인 도구를 사용하지 못 한다.
* 프로그램 이해를 위하여 테스트나 디버깅 도구를 사용하는 데 그친다.
