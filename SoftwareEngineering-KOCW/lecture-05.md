# 객체지향 개념의 이해

**내가 가진 도구가 망치 뿐이라면 모든 문제가 다 못으로 보인다.**

![절차지향과 객체지향](https://miro.medium.com/max/1600/1*1RDWiHNMBy9iR434gVibgw.png)

## Old way

* 프로그램은 데이터와 함수로 구성
* 함수는 데이터를 조작
* 프로그램을 조직화하기 위함
    * 기능적 분할
    * 자료 흐름도
    * 모듈

### 너무 자세한 요구의 위임

```c
void ShowContent(MailItem *mailitem)
{
    // 생략
    switch (mailitem -> type)
    {
        case EMAIL:
            ShowContentOfEmail(mailitem);
            break;
        case FAX:
            ShowContentOfFax(mailitem);
            break;
        // 생략
    }
}
```

* 시스템이 함수의 집합
* 함수가 서로 자료를 주고 받음
* 함수와 자료가 분리
* 설계 작업
    * 자료, 함수 안의 알고리즘, 함수의 구조에 초점
* 함수의 재사용이 어려움
    * 다른 사람의 코드를 계속 읽어보고 이해하려고 해야 함
    * 수정할 때도 마찬가지
* 설계 방법
    * 함수와 자료를 별도로 생각
    * 모듈 사이의 연관 복잡

![절차적 프로그래밍의 구조](https://www.ebuddyblog.com/wp-content/uploads/2017/03/introduction-to-oops-concepts-5-638.jpg)

## New way

* 프로그램은 클래스의 집합
* 객체지향 프로그래밍
    * 어떤 객체가 필요하며
    * 어떤 오퍼레이션이 필요
    * 어떻게 서로 협력해야 하는지를 결정하는 일
* 메일 타입 추가가 용이
    * 다른 클래스가 어떤 일을 하는지 관심을 덜 가질 수 있음

![객체지향 프로그래밍](https://i.pinimg.com/originals/e7/22/72/e72272c03c5faeda440d4fafbda8c7c1.jpg)

### 복잡함을 잘 다루는 방법

* PC 하드웨어(버스, 메모리, CPU...)
    * 내부는 복잡
    * 인터페이스는 간단
    * 새로운 PC 설계가 간단해짐
* 객체
    * 내부 - 데이터와 이를 조작하는 함수가 있는 작은 단위의 프로그램
    * 외부 - 함수 인터페이스, 내부의 복잡한 변수는 감추어짐

### 클래스와 객체

* 클래스는 객체를 정의한 템플릿
* 객체는 생성자로 생성
    * 같은 클래스에 속하는 객체는 같은 메소드를 가짐
    * 각 객체와 관련된 인스턴스 변수의 값은 다름
* 메소드와 변수
    * 객체와 관련된 메소드가 실행되면 인스턴스 변수의 값을 바꾸어 놓음

#### 클래스

**클래스 = 자료 + 오퍼레이션**

* 클래스에 의하여 제공될 서비스를 정의한 것(public)
* 내부에서만 사용될 메소드 정의(private)
* 인스턴스 변수 - 외부 조작이 불가능하도록 private 선언

![클래스 다이어그램](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2543F63C58E8BDD604)

#### 인스턴스

* 클래스의 인스턴스
* 구체적인 자료값을 가짐

#### 메소드

* 메소드는 문장 블록과는 다르게 중첩될 수 없음
* 메소드는 호출되기 전에 선언할 필요가 없음
* 정의와 호출 순서가 뒤바뀌어도 됨
* 실행은 항상 메인 메소드부터(c/c++)

#### 상속

* 상속의 의미
    * 상위 클래스의 속성과 연산을 물려 받음
    * 슈퍼클래스, 서브클래스

#### 다형성(ploymorphism)

* 다형성이란 여러 형태를 가지고 있다는 의미
    * 여러 형태를 받아들일 수 있음
* 같은 이름의 메시지를 다른 객체, 서브클래스에서 가질 수 있음
* 변수가 서브클래스의 객체를 가질 수 있음
* 서브클래스는 슈퍼클래스 객체를 캐스팅할 수 있음

## 클래스의 관계

* 연관(association)
* 전체, 부분(whole, part)
* 상속(inheritance)
* 사용(use)

![클래스의 관계](https://i.imgur.com/5O31wUj.png)

### 연관 관계

* 객체와 객체를 연결하는 구조적인 관계
* 방향성과 다중도를 고려

```java
// 배열 kids는 Child에 대한 레퍼런스를 지정
Class Mother {
    // 생략
    private Child[] kids = new Child[20];
    pubilc addChild(Child ch);
}

// 변수 mom이 mother 객체를 레퍼런스함
// mom을 선언하므로 연관관계를 맺음
Class Child {
    // 생략
    private Mother mom;
    public setMom(mon);
}
```

* 추적 가능성(navigability) 확인
* 서버클래스의 표현을 바꿀 때, 클라이언트 코드를 변경할 필요 없음
    * kids 변수를 벡터로 변환 가능
    * kids 변수를 private 선언하면 프로그램에 영향을 주지 않고 서버클래스(Mother)의 표현을 바꿀 수 있음

### 전체, 부분 관계

#### 구성 관계

* 전체 개념 안에 구성요소 존재(테이블 - 4개의 다리, 1개의 상판)
* 연관 관계의 일종으로 관계 표시는 없어도 됨
* 방향성, 추적 가능성 고려
* 컨테이너 객체 이용
* 대부분 has, comprise, consist of의 의미
* 클래스 관계의 80% 이상 차지하는 경우가 많음

##### 구성 관계의 특성

* 구성요소가 없이 전체가 존재할 수 없음
* 구성요소는 언제나 하나의 전체 객체에 대한 부품
* 구성 관계는 이질적 구성요소로 구성

#### 집합 관계

* 숲은 나무의 집합, 시/도는 군/구의 집합
* 컨테이너 클래스 사용
* 전체 개념의 클래스로부터 구성요소를 찾을 수 있음

##### 집합 관계의 특성

* 구성요소가 없이 전체가 존재할 수 있음
* 구성요소는 하나 이상의 전체집합에 소속 가능함
* 구성관계는 동질적 구성요소로 되어 있음

#### 상속 관계

* 일반적 개념의 클래스와 더 구체적 클래스의 관계
* a kid of의 관계
* 단일 상속, 다중 상속의 관계가 있음

#### 사용 관계

* 한 클래스가 다른 클래스의 코드 안에서 사용할 때
* 코드 상의 의존 관계, 종속된 관계
* 일반적 유형
    * 오퍼레이션의 매개변수로 다른 클래스를 사용하는 클래스 간의 연결
* 디자인 단계에서 모든 사용 관계를 파악하는 것은 어려움

#### 관계의 비교

|항목|연관관계|전체부분관계|상속관계|사용관계|
|---|------|--------|------|------|
|관계|클래스 사이에 영구적인 의미가 있는 관계|명확한 전체, 부분 개념|일반적, 구체적 관계|한 클래스에서 다른 클래스 객체의 서비스를 사용|
|유지기간|클래스 상태의 일부분으로 객체가 살아있는 동안만 유지|클래스 상태의 일부분으로 클래스 객체가 살아 있는 동안만 유지|서브클래스가 정의될 동안만 영구적|클라이언트나 서버 메소드가 활성된 경우만 관계 유지|
|구현|관련된 객체에 대한 인스턴스 변수를 정의, 다중도를 위하여 컨테이너 객체 사용|링크에 대한 레퍼런스를 인스턴스 변수로 정의, 다중도를 위하여 컨테이너 객체 사용|상속을 사용, java의 경우 서브클래스가 슈퍼클래스를 확장|클라이언트 클래스 메소드가 서버 클래스에 대한 레퍼런스를 매개변수로 가짐|
