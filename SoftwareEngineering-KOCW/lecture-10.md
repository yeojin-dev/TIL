# 소프트웨어 아키텍처

## 소프트웨어 아키텍처란?

* 건축 설계에 비유
    * 설계와 시공에 대한 가이드가 될 큰 밑그림
    * 일관적인 모양과 조화를 위한 스타일을 정하는 작업
* 아키텍처 스타일
    * 구조의 유형
* 아키텍처가 중요한 이유
    * 일단 시스템이 개발된 뒤에는 잘못된 구조를 바로잡기가 쉽지 않음
* 범위
    * 시스템 분할, 전체 제어 흐름, 오류 처리 방침, 서브시스템 간의 통신 프로토콜을 포함

## 모듈, 서브 시스템, 컴포넌트

### 모듈

* 집합 식별자가 있는 경계가 있는 요소, 어휘적으로 인접한 일련의 연속된 프로그램 명령문
* 프로그래밍 언어 수준에 따라 정의된 컴포넌트

### 서브 시스템

* 대규모 시스템의 일부분으로 규정된 인터페이스를 가짐
* 자바 패키지가 대표적

### 컴포넌트

* 분명한 역할을 가지고 있는 하드웨어 또는 소프트웨어 조각

### 프레임워크

* 완성되지 않은 뼈대

## 아키텍처 스타일

### 저장소 구조(reposigtory)

![저장소 구조](https://www.tutorialspoint.com/software_architecture_design/images/data_centered_architecture.jpg)

* 서브 시스템들이 단일 중앙 저장소의 자료를 접근하고 변경
* 서브 시스템들은 독립적이고 중앙 자료 저장소를 이용하여 상호 대화
* 사례
    * 금여 시스템
    * 은행 시스템과 같은 데이터

* 장점 : 컴포넌트를 추가하기가 용이함
* 단점 : 저장소를 관리하는 것 자체가 병목 현상을 일으킴

### MVC 구조

![MVC](https://mdn.mozillademos.org/files/16042/model-view-controller-light-blue.png)

* MVC
    * 모델 서브 시스템 : 도메인의 지식을 저장, 보관
    * 뷰 서브 시스템 : 사용자에게 보여줌
    * 제어 서브 시스템 : 사용자와의 상호 작용을 관리

* 분리하는 이유 : 사용자 인터페이스, 즉 뷰와 제어가 도메인 지식을 나타내는 모델보다는 더 자주 변경될 수 있기 때문

### 클라이언트, 서버 구조

![클라이언트, 서버 구조](https://t1.daumcdn.net/cfile/tistory/9994494C5C807AE00F)

* 서버는 클라이언트에게 서비스를 제공
* 서비스의 요구
    * 원격 호출 메커니즘
    * Java RMI의 공통 객체 브로커
* 클라이언트
    * 사용자로부터 입력을 받아 범위를 체크
    * 데이터베이스 트랜잭션을 구동하여 필요한 모든 데이터를 수집
* 서버
    * 트랜잭션을 수행
    * 데이터 일관성 보장

### 계층 구조

![OSI 7 layers](https://electricala2z.com/wp-content/uploads/2017/10/osi-model.gif)

* 각 서브 시스템이 하나의 계층이 되어 하위층이 제공하는 서비스를 상위층의 서브 시스템이 사용
* 추상화의 성질을 잘 이용한 구조
* 장점 : 각 층을 필요에 따라 쉽게 변경할 수 있음
* 단점 : 성능 저하를 가져올 수 있음

### 파이프 필터 구조

* 서브 시스템이 입력 데이터를 받아 처리하고 결과를 다른 시스템에 보내는 작업이 반복
* 서브 시스템을 필터라고 하고 서브 시스템 사이의 관계를 파이프라고 부름
* 대표적인 예로 unix shell 시스템이 있음

## 스타일별 설계 원리 반영

|항목|계층 구조|클라이언트 서버|MVC|
|---|-------|-----------|---|
|분할 정복|분리된 계층이 독립적으로 설계됨|클라이어늩와 서버로 확실히 분리. 별도로 개발될 수 있음|3가지 컴포넌트가 독립적으로 설계될 수 있음|
|계층 응집도(층 안에 관련 서비스가 집합)|서버가 클라이언트에게 응집도 높은 서비스를 제공|뷰와 제어부분이 단일 UI 계층에 같이 있다면 계층 응집도가 큼|
|결합력 감소|잘 설계된 하위층은 상위층에 대하여 알지 못 함. 상위층이 하위층에 영향을 주지 않고 교체됨|분산된 컴포넌트들 사이에 통신 채널이 유일함. 제어 결합이 있지만 전달되는 데이터가 단순하여 결합도 줄임|세 컴포넌트 사이의 통신 채널이 간소화 됨|
|추상화 증진|상위층을 설계할 때 하위층이 어떻게 구현되었는지 상세히 알 필요가 없음|분산된 컴포넌트를 분리함으로 좋은 추상성을 가짐||
|재사용성 증진|하위층은 범용적으로 설계되어 다른 시스템에서 같은 서비스를 제공하도록 재사용될 수 있다.|||
|융통성|새로운 기능을 하위층 서비스에 추가하거나 상위층을 교체할 수 있음|서버와 클라이언트를 추가하여 쉽게 분산 시스템을 재구성할 수 있음|뷰, 제어를 변경하여 UI를 쉽게 갱신할 수 있음|

## 응집도 높이기

* 응집도는 모듈 안의 오퍼레이션들이 얼마나 밀접히 관련 있는지를 말함
* 밀접한 관계는 이해도 및 간결성을 높임
* 잘 추상화 된 클래스는 응집도가 높음
* 정신 없는 클래스 금지

## 휴리스틱

* 설계에는 정답이 없음
* 휴리스틱을 적용하면 좋은 설계를 얻을 수 있음

### 9가지 휴리스틱 원칙

1. 객체를 식별하라
2. 일관적인 추상을 적용하라
3. 구현에서 결정할 상세한 것은 캡슐화하라
4. 상속 보다는 합성을 사용하라
5. 정보를 감춰라
6. 느슨한 결합, 강한 응집을 유지하라
7. 변경될 것 같은 부분을 식별하라
8. 디자인 패턴을 사용하라
9. 테스트 하기 쉽게 만들어라

## 상속과 합성

* 상속

```java
class Fruit {

}
class Apple extends Fruit {

}
```

* 합성

```java
class Fruit {

}
class Apple {
    private Fruit fruit = new Fruit();
}
```

## 합성(composition)

* 재사용이 용이
* 클래스 라이브러리를 슬림하게 유지(이해 쉬움)
* 캡슐화를 그대로 유지
* 결합을 약하게 함
* 런타임 바인딩 가능
* 상속은 추상화를 도모하나 캡슐화를 깨트림(is-a 관계 이외에는 사용을 자제)

## UML 패키지 다이어그램

![UML 패키지 다이어그램](https://www.uml-diagrams.org/package-diagrams/model-diagram-elements.png)

* UML에서 서브 시스템을 표현할 때 패키지라는 개념 도입

* 패키지
    * 클래스를 의미 있는 관련된 그룹으로 구성하는 매커니즘

* 패키지 사용의 장점
    * 복잡한 시스템을 서브 시스템으로 나누어 적절히 컨트롤
    * 패키지 이름을 정의하여 알고 있으면 외부에서 패키지 안의 자세한 사항을 모르더라도 import 후 사용 가능

* 소프트웨어 구조를 표현하는 것에 적합
    * 패키지가 클래스의 그룹이므로 높은 수준의 추상화된 서브 시스템을 표현 가능
