# 소프트웨어 개발 프로세스

## 소프트웨어 생명주기 모형

### 생명주기

* 컨셉트를 정하는 것부터 소멸될 때까지
* 몇 달 또는 몇 년이 걸릴 수 있음

### 각 단계의 목표

* 명확한 작업 단계
* 손에 잡히는 결과
* 작업의 검토
* 다음 단계의 명시

### 생명주기를 사용하는 이점

* 어떤 작업을 해야 할지를 구조적으로 제공
* "큰 그림"을 볼 수 있게 하고 따라가면서 작업했을 때 실수에 괘념하지 않고 목표에 도달할 수 있음
* 생명주기가 없다면 결정이 중구난방이 될 수 있음
* 관리 도구를 사용함

## 프로세스의 중요성

![Project with little attention on process](https://image1.slideserve.com/1583055/project-with-little-attention-on-process-l.jpg)

![Project that focus early attention on process](https://chrisme1320blog.files.wordpress.com/2017/02/realprocess.png?w=768)

## Code-and-fix 모형

* 공식적인 가이드라인이나 프로세스 없이 소프트웨어를 개발해 나가는 형태
* 나쁜 모형

### 단점

* 중요한 작업(설계, 테스트)들이 무시됨
* 각 작업이 언제 시작되어야 할지 언제 끝날지 불명확
* 대규모 작업에 적용하기 어려움
* 개인의 작업을 리뷰하거나 평가하기 어려움
* **문제를 늦게 발견할수록 고치는 비용은 커짐**

## 폭포수 모형

![폭포수 모형](https://i.pinimg.com/originals/f4/44/1f/f4441fb6a29d90afcab1814bae2490fc.png)

### 계획

* **WHY**
* 범위 정하기
* 산정
* 리스크 분석
* 일정 계획
* 관리 전략 수립

### 요구 분석

* **WHAT**
* 요구 - 시스템이 가져야 할 능력(capability)과 조건(condition)
* 응용 분야(도메인 지식)에 집중
* 가장 중요하고도 어려운 단계 - 사전에 오류를 발견하지 않으면 오류 해결 비용이 점점 늘어남
* 결과물 : 요구분석서(Software Requirements Spec)

![Phase That a Defect Is Corrected](https://www.researchgate.net/profile/Ljubomir_Lazic3/publication/228847861/figure/fig1/AS:340395444719626@1458168006951/Engineering-Rules-for-Cost-Of-Defect-Removal-10.png)

### 설계

* **HOW**
* 솔루션에 집중
* 아키텍처 설계
* 데이터베이스 설계
* UI 설계
* 상세 설계
* 결과물 : 설계서(Software Design)

### 구현

* **DO IT**
* 코딩과 단위 테스트
* 설계/통합 단계와 겹치기도 함
    * 일정 줄이기 위하여
    * 협업이 필요한 경우
* 특징 : 압력 증가, 최고의 인력 투입
* 이슈 : Last minute change, Communication Overhead, 하청 관리

### 통합과 테스트

* 병행
* 모듈의 통합으로 시작
* 점차 완성된 모듈을 추가
* 통합은 개발자가 주로 담당, 테스트는 QA팀이 주로 담당
* 단계적인 테스트 : 단위, 통합, 시스템
* 목적 중심 테스트 : 스트레스 테스트, 성능 테스트, 베타 테스트, Acceptance 테스트, Usability 테스트

### 설치와 유지보수

* 시스템의 타입에 따라 다른 설치 방법
* 이전 정책
* 시스템 사용을 시작하게 하는 방법
    * 병행 운용
* 설치는 개발 프로젝트의 일부, 유지보수는 별개
* 유지보수
    * 결함을 고침
    * 새 기능 추가
    * 성능 개선

### 폭포수 모형 정리

* 1970년대 항공, 국방 소프트웨어 개발 경험으로 습득
* 각 단계가 다음 단계 시작 전에 끝나야 함
* 단순하거나 응용 분야를 잘 알고 있는 경우 적합
* 결과물 정의가 중요함
* Method vs. Methodology

### 폭포수 모델의 단계적 결과물

![폭포수 모델의 단계적 결과물](https://slidesplayer.org/slide/15910101/88/images/22/폭포수+모델의+단계별+결과물.jpg)

### 폭포수 모델의 장단점

* 장점
    * 프로세스가 단순하여 초보자가 쉽게 적용 가능
    * 중간 산출물이 명확, 관리하기 좋음
    * 코드 생성 전 충분한 연구와 분석 단계

* 단점
    * 처음 단계를 지나치게 강조하면 코딩, 테스트가 지연
    * 각 단계의 전환에 많은 노력
    * 프로토타입과 재사용의 기회가 줄어듦
    * 소용 없는 여러 문서를 생산할 가능성 있음

* 적용
    * 잘 모르는 문제나 연구 중심 문제에 적합
    * 변화가 적은 프로젝트에 적합

## 프로토타이핑 모형(Rapid Prototyping Model)

* 프로토타입 적용
    * 사용자의 요구를 더 정확히 추출
    * 알고리즘의 타당성, 운영체제와의 조화, 인터페이스의 시험 제작

* 프로토타이핑 도구
    * 화면 생성기
    * 비주얼 프로그래밍, 4세대 언어 등

* 공동의 참조 모델
    * 사용자와 개발자의 의사소통을 도와주는 좋은 매개체

* 프로토타입의 목적
    * 단순한 요구 추출 - 만들고 버림
    * 제작 가능성 타진 - 개발 단계에서 유지보수가 이루어짐

### 프로토타이핑 모형의 장단점

* 장점
    * 사용자의 의견 반영이 잘 됨
    * 사용자가 더 관심을 가지고 참여할 수 있고 개발자는 요구를 더 정확히 도출할 수 있음

* 단점
    * 오해, 기대심리 유발
    * 관리가 어려움(중간 산출물 정의가 난해)

* 적용
    * 개발 착수 시점에 요구가 불투명할 때
    * 실험적으로 실현 가능성을 타진해보고 싶을 때
    * 혁신적인 기술을 사용해보고 싶을 때

## 점증적 모형

* 개발 사이클이 짧은 환경
    * 빠른 시간 안에 시장에 출시하여야 이윤에 직결(위험도를 줄임)
    * 개발 시간을 줄이는 법 - 시스템을 나누어 릴리스

* 릴리즈 구성 방법
    * 점증적 방법 - 기능별로 릴리스
    * 반복적 방법 - 릴리스 할 때마다 기능의 완성도를 높임

* 단계적 개발
    * 기능이 부족하더라도 초기에 사용 교육 가능
    * 처음 시장에 내놓는 소프트웨어는 시장을 빨리 형성시킬 수 있음
    * 자주 릴리스 하면 가동 중인 시스템에서 일어나는 예상하지 못 했던 문제를 신속 꾸준히 고쳐나갈 수 있음
    * 개발팀이 릴리스마다 다른 전문 영역에 초점을 둘 수 있음

## 나선형 모형

* 소프트웨어의 기능을 나누어 점증적으로 개발
    * 실패 위험 줄임
    * 테스트 용이
    * 피드백

* 여러 번의 점증적인 릴리스

* 진화 단계
    1. 계획 수립 : 목표, 기능 선택, 제약 조건의 결정
    2. 위험 분석 : 기능 선택의 우선순위, 위험요소 분석
    3. 개발 : 선택된 기능의 개발
    4. 평가 : 개발 결과의 평가

### 나선형 모형의 장단점

* 장점
    * 대규모 시스템 개발에 적합(risk reduction mechanism)
    * 반복적인 개발 및 테스트 - 강인성 향상
    * 한 사이클에 추가 못 한 기능은 다음 단계에서 추가 가능

* 단점
    * 관리가 중요
    * 위험 분석이 중요
    * 새로운 모형

* 적용
    * 재정적 또는 기술적으로 위험 부담이 큰 경우
    * 요구 사항이나 아키텍처 이해에 어려운 경우
