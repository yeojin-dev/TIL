# 소프트웨어 개발 프로세스

## 소프트웨어 생명주기 모형

### 생명주기

* 컨셉트를 정하는 것부터 소멸될 때까지
* 몇 달 또는 몇 년이 걸릴 수 있음

### 각 단계의 목표

* 명확한 작업 단계
* 손에 잡히는 결과
* 작업의 검토
* 다음 단계의 명시

### 생명주기를 사용하는 이점

* 어떤 작업을 해야 할지를 구조적으로 제공
* "큰 그림"을 볼 수 있게 하고 따라가면서 작업했을 때 실수에 괘념하지 않고 목표에 도달할 수 있음
* 생명주기가 없다면 결정이 중구난방이 될 수 있음
* 관리 도구를 사용함

## 프로세스의 중요성

![Project with little attention on process](https://image1.slideserve.com/1583055/project-with-little-attention-on-process-l.jpg)

![Project that focus early attention on process](https://chrisme1320blog.files.wordpress.com/2017/02/realprocess.png?w=768)

## Code-and-fix 모형

* 공식적인 가이드라인이나 프로세스 없이 소프트웨어를 개발해 나가는 형태
* 나쁜 모형

### 단점

* 중요한 작업(설계, 테스트)들이 무시됨
* 각 작업이 언제 시작되어야 할지 언제 끝날지 불명확
* 대규모 작업에 적용하기 어려움
* 개인의 작업을 리뷰하거나 평가하기 어려움
* **문제를 늦게 발견할수록 고치는 비용은 커짐**

## 폭포수 모형

![폭포수 모형](https://i.pinimg.com/originals/f4/44/1f/f4441fb6a29d90afcab1814bae2490fc.png)

### 계획

* **WHY**
* 범위 정하기
* 산정
* 리스크 분석
* 일정 계획
* 관리 전략 수립

### 요구 분석

* **WHAT**
* 요구 - 시스템이 가져야 할 능력(capability)과 조건(condition)
* 응용 분야(도메인 지식)에 집중
* 가장 중요하고도 어려운 단계 - 사전에 오류를 발견하지 않으면 오류 해결 비용이 점점 늘어남
* 결과물 : 요구분석서(Software Requirements Spec)

![Phase That a Defect Is Corrected](https://www.researchgate.net/profile/Ljubomir_Lazic3/publication/228847861/figure/fig1/AS:340395444719626@1458168006951/Engineering-Rules-for-Cost-Of-Defect-Removal-10.png)

### 설계

* **HOW**
* 솔루션에 집중
* 아키텍처 설계
* 데이터베이스 설계
* UI 설계
* 상세 설계
* 결과물 : 설계서(Software Design)

### 구현

* **DO IT**
* 코딩과 단위 테스트
* 설계/통합 단계와 겹치기도 함
    * 일정 줄이기 위하여
    * 협업이 필요한 경우
* 특징 : 압력 증가, 최고의 인력 투입
* 이슈 : Last minute change, Communication Overhead, 하청 관리

### 통합과 테스트

* 병행
* 모듈의 통합으로 시작
* 점차 완성된 모듈을 추가
* 통합은 개발자가 주로 담당, 테스트는 QA팀이 주로 담당
* 단계적인 테스트 : 단위, 통합, 시스템
* 목적 중심 테스트 : 스트레스 테스트, 성능 테스트, 베타 테스트, Acceptance 테스트, Usability 테스트

### 설치와 유지보수

* 시스템의 타입에 따라 다른 설치 방법
* 이전 정책
* 시스템 사용을 시작하게 하는 방법
    * 병행 운용
* 설치는 개발 프로젝트의 일부, 유지보수는 별개
* 유지보수
    * 결함을 고침
    * 새 기능 추가
    * 성능 개선

### 폭포수 모형 정리

* 1970년대 항공, 국방 소프트웨어 개발 경험으로 습득
* 각 단계가 다음 단계 시작 전에 끝나야 함
* 단순하거나 응용 분야를 잘 알고 있는 경우 적합
* 결과물 정의가 중요함
* Method vs. Methodology

### 폭포수 모델의 단계적 결과물

![폭포수 모델의 단계적 결과물](https://slidesplayer.org/slide/15910101/88/images/22/폭포수+모델의+단계별+결과물.jpg)

### 폭포수 모델의 장단점

* 장점
    * 프로세스가 단순하여 초보자가 쉽게 적용 가능
    * 중간 산출물이 명확, 관리하기 좋음
    * 코드 생성 전 충분한 연구와 분석 단계

* 단점
    * 처음 단계를 지나치게 강조하면 코딩, 테스트가 지연
    * 각 단계의 전환에 많은 노력
    * 프로토타입과 재사용의 기회가 줄어듦
    * 소용 없는 여러 문서를 생산할 가능성 있음

* 적용
    * 잘 모르는 문제나 연구 중심 문제에 적합
    * 변화가 적은 프로젝트에 적합

## 프로토타이핑 모형(Rapid Prototyping Model)

* 프로토타입 적용
    * 사용자의 요구를 더 정확히 추출
    * 알고리즘의 타당성, 운영체제와의 조화, 인터페이스의 시험 제작

* 프로토타이핑 도구
    * 화면 생성기
    * 비주얼 프로그래밍, 4세대 언어 등

* 공동의 참조 모델
    * 사용자와 개발자의 의사소통을 도와주는 좋은 매개체

* 프로토타입의 목적
    * 단순한 요구 추출 - 만들고 버림
    * 제작 가능성 타진 - 개발 단계에서 유지보수가 이루어짐

### 프로토타이핑 모형의 장단점

* 장점
    * 사용자의 의견 반영이 잘 됨
    * 사용자가 더 관심을 가지고 참여할 수 있고 개발자는 요구를 더 정확히 도출할 수 있음

* 단점
    * 오해, 기대심리 유발
    * 관리가 어려움(중간 산출물 정의가 난해)

* 적용
    * 개발 착수 시점에 요구가 불투명할 때
    * 실험적으로 실현 가능성을 타진해보고 싶을 때
    * 혁신적인 기술을 사용해보고 싶을 때

## 점증적 모형

* 개발 사이클이 짧은 환경
    * 빠른 시간 안에 시장에 출시하여야 이윤에 직결(위험도를 줄임)
    * 개발 시간을 줄이는 법 - 시스템을 나누어 릴리스

* 릴리즈 구성 방법
    * 점증적 방법 - 기능별로 릴리스
    * 반복적 방법 - 릴리스 할 때마다 기능의 완성도를 높임

* 단계적 개발
    * 기능이 부족하더라도 초기에 사용 교육 가능
    * 처음 시장에 내놓는 소프트웨어는 시장을 빨리 형성시킬 수 있음
    * 자주 릴리스 하면 가동 중인 시스템에서 일어나는 예상하지 못 했던 문제를 신속 꾸준히 고쳐나갈 수 있음
    * 개발팀이 릴리스마다 다른 전문 영역에 초점을 둘 수 있음

## 나선형 모형

* 소프트웨어의 기능을 나누어 점증적으로 개발
    * 실패 위험 줄임
    * 테스트 용이
    * 피드백

* 여러 번의 점증적인 릴리스

* 진화 단계
    1. 계획 수립 : 목표, 기능 선택, 제약 조건의 결정
    2. 위험 분석 : 기능 선택의 우선순위, 위험요소 분석
    3. 개발 : 선택된 기능의 개발
    4. 평가 : 개발 결과의 평가

### 나선형 모형의 장단점

* 장점
    * 대규모 시스템 개발에 적합(risk reduction mechanism)
    * 반복적인 개발 및 테스트 - 강인성 향상
    * 한 사이클에 추가 못 한 기능은 다음 단계에서 추가 가능

* 단점
    * 관리가 중요
    * 위험 분석이 중요
    * 새로운 모형

* 적용
    * 재정적 또는 기술적으로 위험 부담이 큰 경우
    * 요구 사항이나 아키텍처 이해에 어려운 경우

## V(Verification) 모형

![V 모델](https://upload.wikimedia.org/wikipedia/commons/9/96/V-model.JPG)

* 폭포수 모형의 변형
    * 감추어진 반복과 재작업을 드러냄
    * 작업과 결과의 검증에 초점

* 장점
    * 오류를 줄일 수 있음

* 단점
    * 반복이 없어 변경을 다루기가 쉽지 않음

* 적용
    * 신뢰성이 높이 요구되는 분야

## 일정 중심 설계 모형

![일정 중심 설계 모형](https://lh3.googleusercontent.com/proxy/a7K1K_9L0ShGs8-V8j_tMmVyIvyRHZHiw0cDXxAMfWaThhvv4NgycQ-YYbBidwjyL0jV3f-UnktIn5IJVDqR5QhcZoyD9Wv0sD1hg0zUAeaYp5u8L8uPFIAwQDdfsXImAKK_CmxRm8RGlwnnLaf71-EtrLRTA8Z90PgifY0hCWFdHRwxSMF7n51svBcbYgqiufXJHy-0xm2zG9l2qPfzOJM)

* 특징
    * 사용자의 요구에 대하여 우선순위를 정하고 이를 기초로 각 사이클을 계획
    * 초기 단계에 중요한 기능들을 설계, 구현하여 시스템의 골격을 만듦
    * 상대적으로 덜 중요한 기능을 나중에 함으로 일정 조정 가능

* 단점
    * 우선순위가 낮아 출시에 포함되지 않을 기능을 분석하고 설계하는 데 시간을 낭비

* 적용
    * 소프트웨어 제품의 출시 날짜가 매우 중요한 경우
    * 목표 일정을 달성할 수 있을지 불확실할 때

## 진화적 출시 모형

* 진화적 출시(evolutionary delivery)
    * 고객의 요구를 여러 사이클에 걸쳐 개발하여 보여주면서 제품을 개선해 나가는 모형

* 프로토타이핑 모형과 다른 점
    * 고객의 요구를 프로토타이핑 모형처럼 전적으로 수용하지는 않음
    * 고객의 반응으로 바뀔 가능성이 적은 부분이 시스템의 핵심
    * 프로토타이핑 모형은 시스템에서 눈에 띄는 부분을 먼저 강조하고 나중에 시스템 기반에 있는 구멍을 메워나가는 방식

## 모델이 많은 이유

![각 모델 비교](https://slidesplayer.org/slide/16651245/96/images/52/%EB%AA%A8%EB%8D%B8+%EB%B9%84%EA%B5%90%EC%99%80+%EC%84%A0%ED%83%9D+%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.jpg)

* 모델의 선택은 프로젝트의 상황과 요구에 좌우됨
* 모델을 잘 선택하면 생산성이 높아짐
* 경우에 따라서는 최적의 효과를 내기 위하여 모델의 융합이 이루어지기도 함

## 애자일 모형

[애자일이 도대체 뭐길래?](https://evan-moon.github.io/2019/07/02/what-is-agile/)

* 다른 모델들은 너무 설계 중심이고 개발에 집중하는 시간이 적음
* 스토리 : 시스템의 기능 하나를 내러티브하게 정리
* 2주 안에 스토리를 구현하는 것을 반복
